# Copyright (c) 2020 Lightricks. All rights reserved.
# Created by Ben Yohay.
# frozen_string_literal: true

require_relative "remove_redundant_new_target_settings"

require "xcodeproj"

module Kintsugi
  class << self
    # Applies the changes specified by `changes` to `project`.
    #
    # @param  [Xcodeproj::Project] project
    #         Project to which to apply the changes.
    #
    # @param  [Hash] changes
    #         Changes to apply to `project`. Assumed to be in the format emitted by
    #         Xcodeproj::Differ#project_diff where its `key_1` and `key_2` parameters have values of
    #         `:added` and `:removed` respectively.
    #
    # @return [void]
    #
    def apply_changes_to_project(project, changes)
      unless changes["rootObject"]["mainGroup"].nil?
        if project.root_object.main_group.nil?
          puts "Warning: Main group doesn't exist, ignoring changes to it."
        else
          apply_change_to_component(project.root_object.main_group,
                                    changes["rootObject"]["mainGroup"])
        end
      end

      unless changes["rootObject"]["projectReferences"].nil?
        if changes["rootObject"]["projectReferences"].key?(nil)
          raise "Detected a change to project references that was incorrectly generated by " \
            "Xcodeproj's project_diff function. In short this means that there is no way to know " \
            "which reference this is applied to. To know more about the problem visit this " \
            "issue: https://github.com/CocoaPods/Xcodeproj/issues/816."
        end

        apply_change_to_component(project.root_object, changes["rootObject"]["projectReferences"])
      end

      apply_change_to_component(project.root_object,
                                changes["rootObject"].reject { |key|
                                  %w[mainGroup projectReferences].include?(key)
                                })
    end

    private

    def apply_change_to_component(component, change)
      # TODO: Skip project's display name and the next line won't be needed.
      return if component.is_a?(String)

      (change[:removed] || []).each do |removed_change|
        remove_according_to_isa(component, removed_change)
      end


      (change[:added] || []).each do |added_change|
        add_according_to_isa(component, added_change)
      end

      (change[:diff] || change).each do |change_name, change_value|
        next if %i[added removed].include?(change_name)

        if change_value["isa"]
          object_name_in_component =
            Xcodeproj::Project::Object::CaseConverter.convert_to_ruby(change_name)
          apply_changes_to_component_of_new_type(component, object_name_in_component, change_value)
        else
          handle_change_of_inner_component(component, change_name, change_value)
        end
      end
    end

    def apply_changes_to_component_of_new_type(parent_component, name_in_parent_component, change)
      old_component = parent_component.send(name_in_parent_component)

      new_component = parent_component.project.new(
        Module.const_get("Xcodeproj::Project::#{change["isa"][:added]}")
      )

      copy_attributes_to_new_component(old_component, new_component)
      apply_change_to_component_of_new_type(old_component, new_component, change)

      parent_component.send("#{name_in_parent_component}=", new_component)
    end

    def copy_attributes_to_new_component(old_component, new_component)
      # The change won't describe the attributes that haven't changed, therefore the attributes
      # are copied to the new component.
      old_component.attributes.each do |attribute|
        next if %i[isa display_name].include?(attribute.name) ||
          !new_component.respond_to?(attribute.name)

        new_component.send("#{attribute.name}=", old_component.send(attribute.name))
      end
    end

    def apply_change_to_component_of_new_type(old_component, new_component, change)
      change.each do |change_name, change_value|
        attribute_name = attribute_name_from_change_name(change_name)

        next if %i[isa display_name].include?(attribute_name) ||
          !new_component.respond_to?(attribute_name)

        # A component that doesn't have any references to it will not be written when the project is
        # saved, therefore it's ok not to handle removing it.
        if simple_attribute?(new_component, attribute_name)
          handle_simple_attribute(new_component, attribute_name, change_value,
                                  ignore_unexpected_removed_value: true)
        elsif change_value[:added]
          add_according_to_isa(new_component, change_value[:added])
        end
      end
    end

    def handle_change_of_inner_component(component, change_name, change_value)
      # In case a file reference has changed, the changes will reflect this both in the referencing
      # component and the file reference. The change can't be applied twice, therefore in the case
      # of the referencing component the change is skipped.
      return if change_name == "fileRef"

      attribute_name = attribute_name_from_change_name(change_name)
      if simple_attribute?(component, attribute_name)
        handle_simple_attribute(component, attribute_name, change_value)
        return
      end

      inner_component = component.send(attribute_name)
      if inner_component.nil?
        puts "Warning: Detected change of an object named '#{change_name}' contained in " \
          "'#{component}' but the object doesn't exist. Ignoring this change."
        return
      end

      if inner_component.is_a?(Xcodeproj::Project::ObjectList)
        apply_change_to_child_components(component, inner_component, change_value)
      else
        apply_change_to_component(inner_component, change_value)
      end
    end

    def attribute_name_from_change_name(change_name)
      if change_name == "fileEncoding"
        change_name.to_sym
      else
        Xcodeproj::Project::Object::CaseConverter.convert_to_ruby(change_name)
      end
    end

    def simple_attribute?(component, attribute_name)
      return false unless component.respond_to?("simple_attributes")

      component.simple_attributes.map { |attribute| attribute.name }.include?(attribute_name)
    end

    def handle_simple_attribute(component, attribute_name, change,
                                ignore_unexpected_removed_value: false)
      new_attribute_value =
        simple_attribute_value_with_change(component.send(attribute_name), change,
                                           ignore_unexpected_removed_value)
      component.send("#{attribute_name}=", new_attribute_value)
    end

    def simple_attribute_value_with_change(old_value, change, ignore_unexpected_removed_value)
      new_value = nil

      if change.key?(:removed)
        new_value =
          handle_removed_change(old_value, change[:removed], ignore_unexpected_removed_value)
      end

      if change.key?(:added)
        new_value = handle_added_change(old_value, change[:added])
      end

      change.each do |subchange_name, subchange_value|
        next if %i[added removed].include?(subchange_name)

        new_value = new_value || old_value || {}
        new_value[subchange_name] =
          simple_attribute_value_with_change(old_value[subchange_name], subchange_value,
                                             ignore_unexpected_removed_value)
      end

      new_value
    end

    def handle_removed_change(old_value, change, ignore_unexpected_removed_value)
      if change.is_a?(Array)
        (old_value || []) - change
      elsif change.is_a?(Hash)
        (old_value || {}).reject do |key, value|
          if value != change[key] && !ignore_unexpected_removed_value
            raise "Trying to remove value #{change[key]} of hash with key #{key} but it changed " \
              "to #{value}."
          end

          change.key?(key)
        end
      elsif change.is_a?(String)
        if old_value != change && !ignore_unexpected_removed_value
          raise "Value changed from #{old_value} to #{change}."
        end

        nil
      elsif !change.nil?
        raise "Unsupported change #{change} of type #{change.class}"
      end
    end

    def handle_added_change(old_value, change)
      if change.is_a?(Array)
        (old_value || []) + change
      elsif change.is_a?(Hash)
        key, value = second_hash_conflicting_value_with_first_hash(old_value || {}, change)
        if key
          raise "Trying to add value #{value} of hash key #{key} but an existing value " \
            "#{old_value[key]} already exists"
        end

        (old_value || {}).merge(change)
      elsif change.is_a?(String)
        change
      elsif !change.nil?
        raise "Unsupported change #{change} of type #{change.class}"
      end
    end

    def second_hash_conflicting_value_with_first_hash(first_hash, second_hash)
      second_hash.find do |key, value|
        first_hash.key?(key) && first_hash[key] != value
      end
    end

    def apply_change_to_child_components(component, child_components, change)
      (change[:removed] || []).each do |removed_change|
        child_component =
          child_components.find { |child| child.display_name == removed_change["displayName"] }

        next if child_component.nil?

        remove_according_to_isa(child_component, removed_change)
      end

      (change[:added] || []).each do |added_change|
        add_according_to_isa(component, added_change)
      end

      (change[:diff] || change).each do |element_name, element_change|
        next if %i[added removed].include?(element_name)

        child_component = child_components.find { |child| child.display_name == element_name }

        if child_component.nil?
          puts "Warning: Detected change to an object named '#{element_name}' contained in " \
            "'#{component}' but the object doesn't exist. Ignoring this change."
          next
        end

        apply_change_to_component(child_component, element_change)
      end
    end

    def remove_according_to_isa(component, change)
      if component.to_tree_hash != change
        raise "Trying to remove an object that changed since then. This is considered a conflict " \
          "that should be resolved manually. Name of the object is: '#{component.display_name}'"
      end

      if change["isa"] == "PBXFileReference"
        remove_build_files_of_file_reference(component, change)
      end

      component.remove_from_project
    end

    def remove_build_files_of_file_reference(file_reference, change)
      # Since the build file's display name depends on the file reference, removing the file
      # reference before removing it will change the build file's display name which will not be
      # detecting when trying to remove the build file. Therefore, the build files that depend on
      # the file reference are removed prior to removing the file reference.
      file_reference.build_files.each do |build_file|
        build_file.referrers.each do |referrer|
          referrer.remove_build_file(build_file)
        end
      end
    end

    def add_according_to_isa(parent_component, change)
      if change.is_a?(Hash) && change["ProjectRef"] && change["ProductGroup"]
        add_subproject_reference(parent_component, change)
        return
      end

      case change["isa"]
      when "PBXNativeTarget"
        add_target(parent_component, change)
      when "PBXFileReference"
        add_file_reference(parent_component, change)
      when "PBXGroup"
        add_group(parent_component, change)
      when "PBXContainerItemProxy"
        add_container_item_proxy(parent_component, change)
      when "PBXTargetDependency"
        add_target_dependency(parent_component, change)
      when "PBXBuildFile"
        add_build_file(parent_component, change)
      when "XCConfigurationList"
        add_build_configuration_list(parent_component, change)
      when "PBXHeadersBuildPhase"
        add_headers_build_phase(parent_component, change)
      when "PBXSourcesBuildPhase"
        add_sources_build_phase(parent_component, change)
      when "PBXCopyFilesBuildPhase"
        add_copy_files_build_phase(parent_component, change)
      when "PBXShellScriptBuildPhase"
        add_shell_script_build_phase(parent_component, change)
      when "PBXFrameworksBuildPhase"
        add_frameworks_build_phase(parent_component, change)
      when "PBXResourcesBuildPhase"
        add_resources_build_phase(parent_component, change)
      when "PBXBuildRule"
        add_build_rule(parent_component, change)
      when "PBXVariantGroup"
        add_variant_group(parent_component, change)
      else
        raise "Trying to add unsupported component type #{change["isa"]}. Full component change " \
          "is: #{change}"
      end
    end

    def add_variant_group(containing_group, change)
      variant_group = containing_group.new_variant_group(change["name"])

      add_attributes_to_component(variant_group, change, ["name"])
    end

    def add_build_rule(target, change)
      build_rule = target.project.new(Xcodeproj::Project::PBXBuildRule)
      add_attributes_to_component(build_rule, change)
      target.build_rules << build_rule
    end

    def add_shell_script_build_phase(target, change)
      build_phase = target.new_shell_script_build_phase(change["displayName"])
      add_attributes_to_component(build_phase, change)
    end

    def add_headers_build_phase(target, change)
      add_attributes_to_component(target.headers_build_phase, change)
    end

    def add_sources_build_phase(target, change)
      add_attributes_to_component(target.source_build_phase, change)
    end

    def add_frameworks_build_phase(target, change)
      add_attributes_to_component(target.frameworks_build_phase, change)
    end

    def add_resources_build_phase(target, change)
      add_attributes_to_component(target.resources_build_phase, change)
    end

    def add_copy_files_build_phase(target, change)
      copy_files_phase_name = change["displayName"] == "CopyFiles" ? nil : change["displayName"]
      copy_files_phase = target.new_copy_files_build_phase(copy_files_phase_name)

      add_attributes_to_component(copy_files_phase, change)
    end

    def add_build_configuration_list(target, change)
      # Assumption: Build configuration list already exists in `target`.
      change["buildConfigurations"].each do |build_configuration_change|
        build_configuration = find_build_configuration(target, build_configuration_change)

        unless build_configuration
          raise "Build configuration #{build_configuration_change["displayName"]} is assumed to " \
            "exist in target #{target}"
        end

        handle_simple_attribute(build_configuration, "build_settings",
                                {added: build_configuration_change["buildSettings"]})

        next unless build_configuration_change.key?("baseConfigurationReference")

        file_reference = target.project.files.find do |file_ref|
          file_ref.path == build_configuration_change["baseConfigurationReference"]["path"]
        end
        build_configuration.base_configuration_reference = file_reference
      end
    end

    def find_build_configuration(target, build_configuration_change)
      target.build_configuration_list.build_configurations.find do |build_configuration|
        build_configuration.display_name == build_configuration_change["displayName"]
      end
    end

    def add_build_file(build_phase, change)
      file_reference =
        if change["fileRef"]["isa"] == "PBXVariantGroup"
          find_variant_group(build_phase.project, change["fileRef"])
        else
          find_file(build_phase.project, change["fileRef"])
        end

      unless file_reference
        puts "Warning: The file reference of build file #{change["displayName"]} was not found " \
          "while trying to add a build file to phase #{build_phase}"
        return
      end

      build_file = build_phase.add_file_reference(file_reference)

      add_attributes_to_component(build_file, change, ["fileRef"])
    end

    def find_variant_group(project, change)
      project.objects.find do |object|
        object.isa == "PBXVariantGroup" && object.display_name == change["displayName"]
      end
    end

    def add_target_dependency(target, change)
      target_dependency = target_with_display_name(target.project, change["displayName"])

      if target_dependency
        target.add_dependency(target_dependency)
        return
      end

      target_dependency = target.project.new(Xcodeproj::Project::PBXTargetDependency)
      add_attributes_to_component(target_dependency, change)

      target.dependencies << target_dependency
    end

    def target_with_display_name(project, display_name)
      project.targets.find do |target|
        next target.display_name == display_name
      end
    end

    def add_container_item_proxy(component, change)
      container_proxy = component.project.new(Xcodeproj::Project::PBXContainerItemProxy)
      container_proxy.container_portal = find_containing_project_uuid(component.project, change)

      add_attributes_to_component(container_proxy, change, ["containerPortal"])

      case component.isa
      when "PBXTargetDependency"
        component.target_proxy = container_proxy
      when "PBXReferenceProxy"
        component.remote_ref = container_proxy
      end
    end

    def find_containing_project_uuid(project, container_item_proxy_change)
      if project.objects_by_uuid[container_item_proxy_change["containerPortal"]]
        return container_item_proxy_change["containerPortal"]
      end

      # The `containerPortal` from `container_item_proxy_change` might not be relevant, since when a
      # project is added its UUID is generated. Instead, existing container item proxies are
      # searched, until one that has the same remote info as the one in
      # `container_item_proxy_change` is found.
      container_item_proxies =
        project.root_object.project_references.map do |project_ref_and_products|
          project_ref_and_products[:project_ref].proxy_containers.find do |container_proxy|
            container_proxy.remote_info == container_item_proxy_change["remoteInfo"]
          end
        end.compact

      if container_item_proxies.length > 1
        puts "Debug: Found more than one potential dependency with name " \
          "'#{container_item_proxy_change["remoteInfo"]}'. Using the first one."
      elsif container_item_proxies.empty?
        puts "Warning: No container portal was found for dependency with name " \
          "'#{container_item_proxy_change["remoteInfo"]}'."
        return
      end

      container_item_proxies.first.container_portal
    end

    def add_subproject_reference(root_object, project_reference_change)
      subproject_reference = find_file(root_object.project, project_reference_change["ProjectRef"])

      # The next line is commented out because UUID is readonly in xcodeproj. A new UUID is created
      # every time a new reference is created. It would have been easier to work with the same UUID
      # as before because the product references contain this UUID in `containerPortal`. However,
      # this is not possible at the moment so in other places exhaustive search is needed to find
      # the correct project. Also, it assumes that the subproject has at least one product.
      # subproject_reference.uuid =
      #   project_reference_change["ProductGroup"]["children"].first["remoteRef"]["containerPortal"]

      product_group_reference = root_object.project.new(Xcodeproj::Project::PBXGroup)
      product_group_reference.name = "Products"

      project_reference_change["ProductGroup"]["children"].each do |product_reference_change|
        product_group_reference << reference_proxy_for_new_project_reference(
          root_object,
          product_reference_change,
          subproject_reference
        )
      end

      attribute =
        Xcodeproj::Project::PBXProject.references_by_keys_attributes
                                      .find { |attrb| attrb.name == :project_references }
      project_reference = Xcodeproj::Project::ObjectDictionary.new(attribute, root_object)
      project_reference[:project_ref] = subproject_reference
      project_reference[:product_group] = product_group_reference
      root_object.project_references << project_reference
    end

    def reference_proxy_for_new_project_reference(component, reference_proxy_change,
                                                  subproject_reference)
      reference_proxy = component.project.new(Xcodeproj::Project::PBXReferenceProxy)
      reference_proxy.remote_ref = container_proxy_for_new_project_reference(
        subproject_reference,
        reference_proxy_change["remoteRef"]
      )
      add_attributes_to_component(reference_proxy, reference_proxy_change, ["remoteRef"])

      reference_proxy
    end

    def container_proxy_for_new_project_reference(subproject_reference, container_item_proxy_change)
      container_proxy = subproject_reference.project.new(Xcodeproj::Project::PBXContainerItemProxy)
      container_proxy.container_portal = subproject_reference.uuid

      add_attributes_to_component(container_proxy, container_item_proxy_change, ["containerPortal"])

      container_proxy
    end

    def add_target(root_object, change)
      type = Xcodeproj::Constants::PRODUCT_TYPE_UTI.key(change["productType"])
      target = root_object.project.new_target(type, change["name"], :ios)
      remove_redundant_new_target_settings(target)

      add_attributes_to_component(target.product_reference, change["productReference"])
      add_attributes_to_component(target, change, %w[name productType productReference])
    end

    def add_file_reference(containing_group, change)
      return if containing_group.display_name == "Products"

      file_reference =
        if File.extname(change["displayName"]) == ".xcodeproj"
          # Hack for adding subprojects.
          Xcodeproj::Project::FileReferencesFactory.send(
            :new_file_reference, containing_group, change["path"],
            change["sourceTree"]
          )
        else
          containing_group.new_reference(change["path"])
        end

      # Apparently, `include_in_index` and `last_known_file_type` are deduced from the file `path`
      # after calling `new_reference`. They are set to `nil` because the file might not have these
      # attributes.
      file_reference.include_in_index = nil
      file_reference.last_known_file_type = nil

      add_attributes_to_component(file_reference, change, ["path"])
    end

    def add_group(containing_group, change)
      group = containing_group.new_group(change["name"], change["path"], change["sourceTree"])
      add_attributes_to_component(group, change, %w[name path sourceTree])
    end

    def add_attributes_to_component(component, changes, ignore_keys = [])
      changes.each do |change_name, change_value|
        next if (%w[isa displayName] + ignore_keys).include?(change_name)

        attribute_name = attribute_name_from_change_name(change_name)
        if simple_attribute?(component, attribute_name)
          handle_simple_attribute(component, attribute_name, {added: change_value})
        else
          case change_value
          when Hash
            add_according_to_isa(component, change_value)
          when Array
            change_value.each do |added_attribute_element|
              add_according_to_isa(component, added_attribute_element)
            end
          else
            raise "Trying to add attribute of unsupported type '#{change_value.class}' to " \
              "object #{component}. Attribute name is '#{change_name}'"
          end
        end
      end
    end

    def find_file(project, file_reference_change)
      case file_reference_change["isa"]
      when "PBXFileReference"
        project.files.find do |file_reference|
          next file_reference.path == file_reference_change["path"]
        end
      when "PBXReferenceProxy"
        find_reference_proxy(project, file_reference_change["remoteRef"])
      else
        raise "Unsupported file reference change of type #{file_reference["isa"]}."
      end
    end

    def find_reference_proxy(project, container_item_proxy_change)
      reference_proxies = project.root_object.project_references.map do |project_ref_and_products|
        project_ref_and_products[:product_group].children.find do |product|
          product.remote_ref.remote_global_id_string ==
            container_item_proxy_change["remoteGlobalIDString"] &&
            product.remote_ref.remote_info == container_item_proxy_change["remoteInfo"]
        end
      end.compact

      if reference_proxies.length > 1
        puts "Debug: Found more than one matching reference proxy with name " \
          "'#{container_item_proxy_change["remoteInfo"]}'. Using the first one."
      elsif reference_proxies.empty?
        puts "Warning: No reference proxy was found for name " \
          "'#{container_item_proxy_change["remoteInfo"]}'."
        return
      end

      reference_proxies.first
    end
  end
end
